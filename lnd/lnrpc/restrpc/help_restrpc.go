package restrpc

import (
	"io"
	"net/http"

	"github.com/golang/protobuf/jsonpb"
	"github.com/golang/protobuf/proto"
	"github.com/gorilla/mux"
	"github.com/pkt-cash/pktd/btcutil/er"
	"github.com/pkt-cash/pktd/pktlog/log"
	"github.com/urfave/cli"
)

var (
	commandMainHelp = cli.Command{
		Name: "pld - Lightning Network Daemon REST interface (pld)",
		Description: `
		For help on a specific command, use the following URIs:
			getinfo          /api/v1/help/meta/getinfo
			getrecoveryinfo  /api/v1/meta/getrecoveryinfo
			debuglevel       /api/v1/meta/debuglevel
			stop             /api/v1/meta/stop
			version          /api/v1/meta/version
	`,
	}

	commandUnlock = cli.Command{
		Name:     "unlock",
		Category: "Startup",
		Usage:    "Unlock an encrypted wallet at startup.",
		Description: `
	The unlock command is used to decrypt lnd's wallet state in order to
	start up. This command MUST be run after booting up lnd before it's
	able to carry out its duties. An exception is if a user is running with
	--noseedbackup, then a default passphrase will be used.

	If the --stateless_init flag is set, no macaroon files are created by
	the daemon. This should be set for every unlock if the daemon was
	initially initialized stateless. Otherwise the daemon will create
	unencrypted macaroon files which could leak information to the system
	that the daemon runs on.
	`,
		Flags: []cli.Flag{
			cli.IntFlag{
				Name: "recovery_window",
				Usage: "address lookahead to resume recovery rescan, " +
					"value should be non-zero --  To recover all " +
					"funds, this should be greater than the " +
					"maximum number of consecutive, unused " +
					"addresses ever generated by the wallet.",
			},
			cli.BoolFlag{
				Name: "stdin",
				Usage: "read password from standard input instead of " +
					"prompting for it. THIS IS CONSIDERED TO " +
					"BE DANGEROUS if the password is located in " +
					"a file that can be read by another user. " +
					"This flag should only be used in " +
					"combination with some sort of password " +
					"manager or secrets vault.",
			},
		},
	}

	commandCreate = cli.Command{
		Name:     "create",
		Category: "Startup",
		Usage:    "Initialize a wallet when starting lnd for the first time.",
		Description: `
	The create command is used to initialize an lnd wallet from scratch for
	the very first time. This is interactive command with one required
	argument (the password), and one optional argument (the mnemonic
	passphrase).

	The first argument (the password) is required and MUST be greater than
	8 characters. This will be used to encrypt the wallet within lnd. This
	MUST be remembered as it will be required to fully start up the daemon.

	The second argument is an optional 24-word mnemonic derived from BIP
	39. If provided, then the internal wallet will use the seed derived
	from this mnemonic to generate all keys.

	This command returns a 24-word seed in the scenario that NO mnemonic
	was provided by the user. This should be written down as it can be used
	to potentially recover all on-chain funds, and most off-chain funds as
	well.

	If the --stateless_init flag is set, no macaroon files are created by
	the daemon. Instead, the binary serialized admin macaroon is returned
	in the answer. This answer MUST be stored somewhere, otherwise all
	access to the RPC server will be lost and the wallet must be recreated
	to re-gain access.
	If the --save_to parameter is set, the macaroon is saved to this file,
	otherwise it is printed to standard out.

	Finally, it's also possible to use this command and a set of static
	channel backups to trigger a recover attempt for the provided Static
	Channel Backups. Only one of the three parameters will be accepted. See
	the restorechanbackup command for further details w.r.t the format
	accepted.
	`,
		Flags: []cli.Flag{
			cli.StringFlag{
				Name: "single_backup",
				Usage: "a hex encoded single channel backup obtained " +
					"from exportchanbackup",
			},
			cli.StringFlag{
				Name: "multi_backup",
				Usage: "a hex encoded multi-channel backup obtained " +
					"from exportchanbackup",
			},
			cli.StringFlag{
				Name:  "multi_file",
				Usage: "the path to a multi-channel back up file",
			},
		},
	}

	commandGetInfo = cli.Command{
		Name:  "getinfo",
		Usage: "Returns basic information related to the active daemon.",
	}

	commandChangePassword = cli.Command{
		Name:     "changepassword",
		Category: "Startup",
		Usage:    "Change an encrypted wallet's password at startup.",
		Description: `
	The changepassword command is used to Change lnd's encrypted wallet's
	password. It will automatically unlock the daemon if the password change
	is successful.

	If one did not specify a password for their wallet (running lnd with
	--noseedbackup), one must restart their daemon without
	--noseedbackup and use this command. The "current password" field
	should be left empty.

	If the daemon was originally initialized stateless, then the
	--stateless_init flag needs to be set for the change password request
	as well! Otherwise the daemon will generate unencrypted macaroon files
	in its file system again and possibly leak sensitive information.
	Changing the password will by default not change the macaroon root key
	(just re-encrypt the macaroon database with the new password). So all
	macaroons will still be valid.
	If one wants to make sure that all previously created macaroons are
	invalidated, a new macaroon root key can be generated by using the
	--new_mac_root_key flag.

	After a successful password change with the --stateless_init flag set,
	the current or new admin macaroon is returned binary serialized in the
	answer. This answer MUST then be stored somewhere, otherwise
	all access to the RPC server will be lost and the wallet must be re-
	created to re-gain access. If the --save_to parameter is set, the
	macaroon is saved to this file, otherwise it is printed to standard out.
	`,
		Flags: []cli.Flag{
			cli.BoolFlag{
				Name: "new_mac_root_key",
				Usage: "rotate the macaroon root key resulting in " +
					"all previously created macaroons to be " +
					"invalidated",
			},
		},
	}
)

//	rest help response
type restHelpResponse struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,json=name,proto3" json:"name,omitempty"`
	Category             string   `protobuf:"bytes,2,opt,name=category,json=category,omitempty,proto3" json:"category,omitempty"`
	Usage                string   `protobuf:"bytes,3,opt,name=usage,json=usage,omitempty,proto3" json:"usage,omitempty"`
	Description          string   `protobuf:"bytes,4,opt,name=desscription,json=desscription,proto3" json:"desscription,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *restHelpResponse) Reset()         { *m = restHelpResponse{} }
func (m *restHelpResponse) String() string { return proto.CompactTextString(m) }
func (m *restHelpResponse) ProtoMessage()  {}

//	marshal rest help response
func marshalHelp(w http.ResponseWriter, cmd cli.Command) er.R {

	marshaler := jsonpb.Marshaler{
		OrigName:     false,
		EnumsAsInts:  false,
		EmitDefaults: true,
		Indent:       "\t",
	}

	s, err := marshaler.MarshalToString(&restHelpResponse{
		Name:        cmd.Name,
		Category:    cmd.Category,
		Usage:       cmd.Usage,
		Description: cmd.Description,
	})
	if err != nil {
		return er.E(err)
	}

	_, err = io.WriteString(w, s)
	if err != nil {
		return er.E(err)
	}

	return nil
}

//	add the main help HTTP handler
func RestHandlersHelp(router *mux.Router) {
	router.HandleFunc("/", getMainHelp)
}

//	main help response
type mainHelpResponse struct {
	HelpMessage string `json:"help"`
}

//	get main help
func getMainHelp(httpResponse http.ResponseWriter, httpRequest *http.Request) {

	//	fill response payload
	/*
		mainHelpResp := &mainHelpResponse{
			HelpMessage: `pld - Lightning Network Daemon REST interface (pld)

		For help on a specific command, use the following URIs:
			getinfo          /api/v1/help/meta/getinfo
			getrecoveryinfo  /api/v1/meta/getrecoveryinfo
			debuglevel       /api/v1/meta/debuglevel
			stop             /api/v1/meta/stop
			version          /api/v1/meta/version`,
		}

		httpResponse.Header().Add("Content-Type", "application/json")
		httpResponse.WriteHeader(http.StatusOK)
		json.NewEncoder(httpResponse).Encode(mainHelpResp)
	*/
	if httpRequest.Method != "GET" {
		httpResponse.Header().Set("Content-Type", "text/plain")
		http.Error(httpResponse, "400 - Request should be a GET because the help endpoint requires no input", http.StatusBadRequest)
		return
	}
	err := marshalHelp(httpResponse, commandMainHelp)
	if err != nil {
		httpResponse.Header().Set("Content-Type", "text/plain")
		http.Error(httpResponse, "500 - Internal Error", http.StatusInternalServerError)
		log.Errorf("Error replying to request for [%s] from [%s] - error sending error, giving up: [%s]",
			httpRequest.RequestURI, httpRequest.RemoteAddr, err)
	}
}
