// Code generated by protoc-gen-go. DO NOT EDIT.
// source: walletunlocker.proto

package lnrpc

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type GenSeedRequest struct {
	//
	//aezeed_passphrase is an optional user provided passphrase that will be used
	//to encrypt the generated aezeed cipher seed. When using REST, this field
	//must be encoded as base64.
	AezeedPassphrase []byte `protobuf:"bytes,1,opt,name=aezeed_passphrase,json=aezeedPassphrase,proto3" json:"aezeed_passphrase,omitempty"`
	//
	//seed_entropy is an optional 16-bytes generated via CSPRNG. If not
	//specified, then a fresh set of randomness will be used to create the seed.
	//When using REST, this field must be encoded as base64.
	SeedEntropy          []byte   `protobuf:"bytes,2,opt,name=seed_entropy,json=seedEntropy,proto3" json:"seed_entropy,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GenSeedRequest) Reset()         { *m = GenSeedRequest{} }
func (m *GenSeedRequest) String() string { return proto.CompactTextString(m) }
func (*GenSeedRequest) ProtoMessage()    {}
func (*GenSeedRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_76e3ed10ed53e4fd, []int{0}
}

func (m *GenSeedRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GenSeedRequest.Unmarshal(m, b)
}
func (m *GenSeedRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GenSeedRequest.Marshal(b, m, deterministic)
}
func (m *GenSeedRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenSeedRequest.Merge(m, src)
}
func (m *GenSeedRequest) XXX_Size() int {
	return xxx_messageInfo_GenSeedRequest.Size(m)
}
func (m *GenSeedRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GenSeedRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GenSeedRequest proto.InternalMessageInfo

func (m *GenSeedRequest) GetAezeedPassphrase() []byte {
	if m != nil {
		return m.AezeedPassphrase
	}
	return nil
}

func (m *GenSeedRequest) GetSeedEntropy() []byte {
	if m != nil {
		return m.SeedEntropy
	}
	return nil
}

type GenSeedResponse struct {
	//
	//cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
	//cipher seed obtained by the user. This field is optional, as if not
	//provided, then the daemon will generate a new cipher seed for the user.
	//Otherwise, then the daemon will attempt to recover the wallet state linked
	//to this cipher seed.
	CipherSeedMnemonic []string `protobuf:"bytes,1,rep,name=cipher_seed_mnemonic,json=cipherSeedMnemonic,proto3" json:"cipher_seed_mnemonic,omitempty"`
	//
	//enciphered_seed are the raw aezeed cipher seed bytes. This is the raw
	//cipher text before run through our mnemonic encoding scheme.
	EncipheredSeed       []byte   `protobuf:"bytes,2,opt,name=enciphered_seed,json=encipheredSeed,proto3" json:"enciphered_seed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GenSeedResponse) Reset()         { *m = GenSeedResponse{} }
func (m *GenSeedResponse) String() string { return proto.CompactTextString(m) }
func (*GenSeedResponse) ProtoMessage()    {}
func (*GenSeedResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_76e3ed10ed53e4fd, []int{1}
}

func (m *GenSeedResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GenSeedResponse.Unmarshal(m, b)
}
func (m *GenSeedResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GenSeedResponse.Marshal(b, m, deterministic)
}
func (m *GenSeedResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenSeedResponse.Merge(m, src)
}
func (m *GenSeedResponse) XXX_Size() int {
	return xxx_messageInfo_GenSeedResponse.Size(m)
}
func (m *GenSeedResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GenSeedResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GenSeedResponse proto.InternalMessageInfo

func (m *GenSeedResponse) GetCipherSeedMnemonic() []string {
	if m != nil {
		return m.CipherSeedMnemonic
	}
	return nil
}

func (m *GenSeedResponse) GetEncipheredSeed() []byte {
	if m != nil {
		return m.EncipheredSeed
	}
	return nil
}

type InitWalletRequest struct {
	//
	//wallet_password is the passphrase that should be used to encrypt the
	//wallet. This MUST be at least 8 chars in length. After creation, this
	//password is required to unlock the daemon. When using REST, this field
	//must be encoded as base64.
	WalletPassword []byte `protobuf:"bytes,1,opt,name=wallet_password,json=walletPassword,proto3" json:"wallet_password,omitempty"`
	//
	//cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
	//cipher seed obtained by the user. This may have been generated by the
	//GenSeed method, or be an existing seed.
	CipherSeedMnemonic []string `protobuf:"bytes,2,rep,name=cipher_seed_mnemonic,json=cipherSeedMnemonic,proto3" json:"cipher_seed_mnemonic,omitempty"`
	//
	//aezeed_passphrase is an optional user provided passphrase that will be used
	//to encrypt the generated aezeed cipher seed. When using REST, this field
	//must be encoded as base64.
	AezeedPassphrase []byte `protobuf:"bytes,3,opt,name=aezeed_passphrase,json=aezeedPassphrase,proto3" json:"aezeed_passphrase,omitempty"`
	//
	//recovery_window is an optional argument specifying the address lookahead
	//when restoring a wallet seed. The recovery window applies to each
	//individual branch of the BIP44 derivation paths. Supplying a recovery
	//window of zero indicates that no addresses should be recovered, such after
	//the first initialization of the wallet.
	RecoveryWindow int32 `protobuf:"varint,4,opt,name=recovery_window,json=recoveryWindow,proto3" json:"recovery_window,omitempty"`
	//
	//channel_backups is an optional argument that allows clients to recover the
	//settled funds within a set of channels. This should be populated if the
	//user was unable to close out all channels and sweep funds before partial or
	//total data loss occurred. If specified, then after on-chain recovery of
	//funds, lnd begin to carry out the data loss recovery protocol in order to
	//recover the funds in each channel from a remote force closed transaction.
	ChannelBackups *ChanBackupSnapshot `protobuf:"bytes,5,opt,name=channel_backups,json=channelBackups,proto3" json:"channel_backups,omitempty"`
	//
	//stateless_init is an optional argument instructing the daemon NOT to create
	//any *.macaroon files in its filesystem. If this parameter is set, then the
	//admin macaroon returned in the response MUST be stored by the caller of the
	//RPC as otherwise all access to the daemon will be lost!
	StatelessInit        bool     `protobuf:"varint,6,opt,name=stateless_init,json=statelessInit,proto3" json:"stateless_init,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InitWalletRequest) Reset()         { *m = InitWalletRequest{} }
func (m *InitWalletRequest) String() string { return proto.CompactTextString(m) }
func (*InitWalletRequest) ProtoMessage()    {}
func (*InitWalletRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_76e3ed10ed53e4fd, []int{2}
}

func (m *InitWalletRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InitWalletRequest.Unmarshal(m, b)
}
func (m *InitWalletRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InitWalletRequest.Marshal(b, m, deterministic)
}
func (m *InitWalletRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitWalletRequest.Merge(m, src)
}
func (m *InitWalletRequest) XXX_Size() int {
	return xxx_messageInfo_InitWalletRequest.Size(m)
}
func (m *InitWalletRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InitWalletRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InitWalletRequest proto.InternalMessageInfo

func (m *InitWalletRequest) GetWalletPassword() []byte {
	if m != nil {
		return m.WalletPassword
	}
	return nil
}

func (m *InitWalletRequest) GetCipherSeedMnemonic() []string {
	if m != nil {
		return m.CipherSeedMnemonic
	}
	return nil
}

func (m *InitWalletRequest) GetAezeedPassphrase() []byte {
	if m != nil {
		return m.AezeedPassphrase
	}
	return nil
}

func (m *InitWalletRequest) GetRecoveryWindow() int32 {
	if m != nil {
		return m.RecoveryWindow
	}
	return 0
}

func (m *InitWalletRequest) GetChannelBackups() *ChanBackupSnapshot {
	if m != nil {
		return m.ChannelBackups
	}
	return nil
}

func (m *InitWalletRequest) GetStatelessInit() bool {
	if m != nil {
		return m.StatelessInit
	}
	return false
}

type InitWalletResponse struct {
	//
	//The binary serialized admin macaroon that can be used to access the daemon
	//after creating the wallet. If the stateless_init parameter was set to true,
	//this is the ONLY copy of the macaroon and MUST be stored safely by the
	//caller. Otherwise a copy of this macaroon is also persisted on disk by the
	//daemon, together with other macaroon files.
	AdminMacaroon        []byte   `protobuf:"bytes,1,opt,name=admin_macaroon,json=adminMacaroon,proto3" json:"admin_macaroon,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InitWalletResponse) Reset()         { *m = InitWalletResponse{} }
func (m *InitWalletResponse) String() string { return proto.CompactTextString(m) }
func (*InitWalletResponse) ProtoMessage()    {}
func (*InitWalletResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_76e3ed10ed53e4fd, []int{3}
}

func (m *InitWalletResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InitWalletResponse.Unmarshal(m, b)
}
func (m *InitWalletResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InitWalletResponse.Marshal(b, m, deterministic)
}
func (m *InitWalletResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitWalletResponse.Merge(m, src)
}
func (m *InitWalletResponse) XXX_Size() int {
	return xxx_messageInfo_InitWalletResponse.Size(m)
}
func (m *InitWalletResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InitWalletResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InitWalletResponse proto.InternalMessageInfo

func (m *InitWalletResponse) GetAdminMacaroon() []byte {
	if m != nil {
		return m.AdminMacaroon
	}
	return nil
}

type UnlockWalletRequest struct {
	//
	//wallet_password should be the current valid private passphrase for the daemon. This
	//will be required to decrypt on-disk material that the daemon requires to
	//function properly. When using REST, this field must be encoded as base64.
	WalletPassword []byte `protobuf:"bytes,1,opt,name=wallet_password,json=walletPassword,proto3" json:"wallet_password,omitempty"`
	// wallet_pub_password is the pubic passphrase by default is nil for pkt
	WalletPubPassword []byte `protobuf:"bytes,2,opt,name=wallet_pub_password,json=walletPubPassword,proto3" json:"wallet_pub_password,omitempty"`
	//
	//recovery_window is an optional argument specifying the address lookahead
	//when restoring a wallet seed. The recovery window applies to each
	//individual branch of the BIP44 derivation paths. Supplying a recovery
	//window of zero indicates that no addresses should be recovered, such after
	//the first initialization of the wallet.
	RecoveryWindow int32 `protobuf:"varint,3,opt,name=recovery_window,json=recoveryWindow,proto3" json:"recovery_window,omitempty"`
	//
	//channel_backups is an optional argument that allows clients to recover the
	//settled funds within a set of channels. This should be populated if the
	//user was unable to close out all channels and sweep funds before partial or
	//total data loss occurred. If specified, then after on-chain recovery of
	//funds, lnd begin to carry out the data loss recovery protocol in order to
	//recover the funds in each channel from a remote force closed transaction.
	ChannelBackups *ChanBackupSnapshot `protobuf:"bytes,4,opt,name=channel_backups,json=channelBackups,proto3" json:"channel_backups,omitempty"`
	//
	//stateless_init is an optional argument instructing the daemon NOT to create
	//any *.macaroon files in its file system.
	StatelessInit        bool     `protobuf:"varint,5,opt,name=stateless_init,json=statelessInit,proto3" json:"stateless_init,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnlockWalletRequest) Reset()         { *m = UnlockWalletRequest{} }
func (m *UnlockWalletRequest) String() string { return proto.CompactTextString(m) }
func (*UnlockWalletRequest) ProtoMessage()    {}
func (*UnlockWalletRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_76e3ed10ed53e4fd, []int{4}
}

func (m *UnlockWalletRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UnlockWalletRequest.Unmarshal(m, b)
}
func (m *UnlockWalletRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UnlockWalletRequest.Marshal(b, m, deterministic)
}
func (m *UnlockWalletRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnlockWalletRequest.Merge(m, src)
}
func (m *UnlockWalletRequest) XXX_Size() int {
	return xxx_messageInfo_UnlockWalletRequest.Size(m)
}
func (m *UnlockWalletRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnlockWalletRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnlockWalletRequest proto.InternalMessageInfo

func (m *UnlockWalletRequest) GetWalletPassword() []byte {
	if m != nil {
		return m.WalletPassword
	}
	return nil
}

func (m *UnlockWalletRequest) GetWalletPubPassword() []byte {
	if m != nil {
		return m.WalletPubPassword
	}
	return nil
}

func (m *UnlockWalletRequest) GetRecoveryWindow() int32 {
	if m != nil {
		return m.RecoveryWindow
	}
	return 0
}

func (m *UnlockWalletRequest) GetChannelBackups() *ChanBackupSnapshot {
	if m != nil {
		return m.ChannelBackups
	}
	return nil
}

func (m *UnlockWalletRequest) GetStatelessInit() bool {
	if m != nil {
		return m.StatelessInit
	}
	return false
}

type UnlockWalletResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnlockWalletResponse) Reset()         { *m = UnlockWalletResponse{} }
func (m *UnlockWalletResponse) String() string { return proto.CompactTextString(m) }
func (*UnlockWalletResponse) ProtoMessage()    {}
func (*UnlockWalletResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_76e3ed10ed53e4fd, []int{5}
}

func (m *UnlockWalletResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UnlockWalletResponse.Unmarshal(m, b)
}
func (m *UnlockWalletResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UnlockWalletResponse.Marshal(b, m, deterministic)
}
func (m *UnlockWalletResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnlockWalletResponse.Merge(m, src)
}
func (m *UnlockWalletResponse) XXX_Size() int {
	return xxx_messageInfo_UnlockWalletResponse.Size(m)
}
func (m *UnlockWalletResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnlockWalletResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnlockWalletResponse proto.InternalMessageInfo

type CreateWalletRequest struct {
	WalletPassword       []byte   `protobuf:"bytes,1,opt,name=wallet_password,json=walletPassword,proto3" json:"wallet_password,omitempty"`
	CipherSeedMnemonic   []string `protobuf:"bytes,2,rep,name=cipher_seed_mnemonic,json=cipherSeedMnemonic,proto3" json:"cipher_seed_mnemonic,omitempty"`
	AezeedPass           []byte   `protobuf:"bytes,3,opt,name=aezeed_pass,json=aezeedPass,proto3" json:"aezeed_pass,omitempty"`
	StatelessInitFlag    bool     `protobuf:"varint,4,opt,name=stateless_init_flag,json=statelessInitFlag,proto3" json:"stateless_init_flag,omitempty"`
	SaveTo               string   `protobuf:"bytes,5,opt,name=save_to,json=saveTo,proto3" json:"save_to,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateWalletRequest) Reset()         { *m = CreateWalletRequest{} }
func (m *CreateWalletRequest) String() string { return proto.CompactTextString(m) }
func (*CreateWalletRequest) ProtoMessage()    {}
func (*CreateWalletRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_76e3ed10ed53e4fd, []int{6}
}

func (m *CreateWalletRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateWalletRequest.Unmarshal(m, b)
}
func (m *CreateWalletRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateWalletRequest.Marshal(b, m, deterministic)
}
func (m *CreateWalletRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateWalletRequest.Merge(m, src)
}
func (m *CreateWalletRequest) XXX_Size() int {
	return xxx_messageInfo_CreateWalletRequest.Size(m)
}
func (m *CreateWalletRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateWalletRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateWalletRequest proto.InternalMessageInfo

func (m *CreateWalletRequest) GetWalletPassword() []byte {
	if m != nil {
		return m.WalletPassword
	}
	return nil
}

func (m *CreateWalletRequest) GetCipherSeedMnemonic() []string {
	if m != nil {
		return m.CipherSeedMnemonic
	}
	return nil
}

func (m *CreateWalletRequest) GetAezeedPass() []byte {
	if m != nil {
		return m.AezeedPass
	}
	return nil
}

func (m *CreateWalletRequest) GetStatelessInitFlag() bool {
	if m != nil {
		return m.StatelessInitFlag
	}
	return false
}

func (m *CreateWalletRequest) GetSaveTo() string {
	if m != nil {
		return m.SaveTo
	}
	return ""
}

type CreateWalletResponse struct {
	Seed                 []string `protobuf:"bytes,1,rep,name=seed,proto3" json:"seed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateWalletResponse) Reset()         { *m = CreateWalletResponse{} }
func (m *CreateWalletResponse) String() string { return proto.CompactTextString(m) }
func (*CreateWalletResponse) ProtoMessage()    {}
func (*CreateWalletResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_76e3ed10ed53e4fd, []int{7}
}

func (m *CreateWalletResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateWalletResponse.Unmarshal(m, b)
}
func (m *CreateWalletResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateWalletResponse.Marshal(b, m, deterministic)
}
func (m *CreateWalletResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateWalletResponse.Merge(m, src)
}
func (m *CreateWalletResponse) XXX_Size() int {
	return xxx_messageInfo_CreateWalletResponse.Size(m)
}
func (m *CreateWalletResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateWalletResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateWalletResponse proto.InternalMessageInfo

func (m *CreateWalletResponse) GetSeed() []string {
	if m != nil {
		return m.Seed
	}
	return nil
}

func init() {
	proto.RegisterType((*GenSeedRequest)(nil), "lnrpc.GenSeedRequest")
	proto.RegisterType((*GenSeedResponse)(nil), "lnrpc.GenSeedResponse")
	proto.RegisterType((*InitWalletRequest)(nil), "lnrpc.InitWalletRequest")
	proto.RegisterType((*InitWalletResponse)(nil), "lnrpc.InitWalletResponse")
	proto.RegisterType((*UnlockWalletRequest)(nil), "lnrpc.UnlockWalletRequest")
	proto.RegisterType((*UnlockWalletResponse)(nil), "lnrpc.UnlockWalletResponse")
	proto.RegisterType((*CreateWalletRequest)(nil), "lnrpc.CreateWalletRequest")
	proto.RegisterType((*CreateWalletResponse)(nil), "lnrpc.CreateWalletResponse")
}

func init() { proto.RegisterFile("walletunlocker.proto", fileDescriptor_76e3ed10ed53e4fd) }

var fileDescriptor_76e3ed10ed53e4fd = []byte{
	// 604 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x94, 0xdf, 0x6e, 0xd3, 0x3e,
	0x14, 0xc7, 0x95, 0x6e, 0xdd, 0x9f, 0xb3, 0x2d, 0xfd, 0xd5, 0xeb, 0x6f, 0x64, 0xe5, 0x82, 0x12,
	0x31, 0xad, 0x02, 0xd1, 0xa1, 0x71, 0x83, 0xc4, 0x15, 0x9b, 0x60, 0xe2, 0x62, 0xd2, 0x94, 0x31,
	0x4d, 0xe2, 0x26, 0xb8, 0xc9, 0x61, 0x89, 0x96, 0xda, 0xc6, 0x76, 0x57, 0x8d, 0x4b, 0x5e, 0x84,
	0x47, 0xe0, 0x7d, 0x78, 0x1a, 0x14, 0xdb, 0x4b, 0x5b, 0x48, 0x25, 0x04, 0x12, 0x17, 0x95, 0xd2,
	0xef, 0xf9, 0x1e, 0xdb, 0xe7, 0x73, 0x8e, 0x0d, 0x9d, 0x09, 0x2d, 0x0a, 0xd4, 0x63, 0x56, 0xf0,
	0xe4, 0x1a, 0xe5, 0x40, 0x48, 0xae, 0x39, 0x69, 0x16, 0x4c, 0x8a, 0xa4, 0xbb, 0x2e, 0x45, 0x62,
	0x95, 0xf0, 0x03, 0xf8, 0x27, 0xc8, 0xce, 0x11, 0xd3, 0x08, 0x3f, 0x8d, 0x51, 0x69, 0xf2, 0x04,
	0xda, 0x14, 0x3f, 0x23, 0xa6, 0xb1, 0xa0, 0x4a, 0x89, 0x4c, 0x52, 0x85, 0x81, 0xd7, 0xf3, 0xfa,
	0x9b, 0xd1, 0x7f, 0x36, 0x70, 0x56, 0xe9, 0xe4, 0x21, 0x6c, 0xaa, 0xd2, 0x8a, 0x4c, 0x4b, 0x2e,
	0x6e, 0x83, 0x86, 0xf1, 0x6d, 0x94, 0xda, 0x6b, 0x2b, 0x85, 0x05, 0xb4, 0xaa, 0x1d, 0x94, 0xe0,
	0x4c, 0x21, 0x79, 0x06, 0x9d, 0x24, 0x17, 0x19, 0xca, 0xd8, 0x24, 0x8f, 0x18, 0x8e, 0x38, 0xcb,
	0x93, 0xc0, 0xeb, 0x2d, 0xf5, 0xd7, 0x23, 0x62, 0x63, 0x65, 0xc6, 0xa9, 0x8b, 0x90, 0x7d, 0x68,
	0x21, 0xb3, 0x3a, 0xa6, 0x26, 0xcb, 0x6d, 0xe5, 0x4f, 0xe5, 0x32, 0x21, 0xfc, 0xd6, 0x80, 0xf6,
	0x5b, 0x96, 0xeb, 0x4b, 0x53, 0xfe, 0x5d, 0x4d, 0xfb, 0xd0, 0xb2, 0x3c, 0x4c, 0x4d, 0x13, 0x2e,
	0x53, 0x57, 0x91, 0x6f, 0xe5, 0x33, 0xa7, 0x2e, 0x3c, 0x59, 0x63, 0xe1, 0xc9, 0x6a, 0x71, 0x2d,
	0x2d, 0xc0, 0xb5, 0x0f, 0x2d, 0x89, 0x09, 0xbf, 0x41, 0x79, 0x1b, 0x4f, 0x72, 0x96, 0xf2, 0x49,
	0xb0, 0xdc, 0xf3, 0xfa, 0xcd, 0xc8, 0xbf, 0x93, 0x2f, 0x8d, 0x4a, 0x8e, 0xa0, 0x95, 0x64, 0x94,
	0x31, 0x2c, 0xe2, 0x21, 0x4d, 0xae, 0xc7, 0x42, 0x05, 0xcd, 0x9e, 0xd7, 0xdf, 0x38, 0xdc, 0x1d,
	0x98, 0x16, 0x0e, 0x8e, 0x33, 0xca, 0x8e, 0x4c, 0xe4, 0x9c, 0x51, 0xa1, 0x32, 0xae, 0x23, 0xdf,
	0x65, 0x58, 0x59, 0x91, 0x3d, 0xf0, 0x95, 0xa6, 0x1a, 0x0b, 0x54, 0x2a, 0xce, 0x59, 0xae, 0x83,
	0x95, 0x9e, 0xd7, 0x5f, 0x8b, 0xb6, 0x2a, 0xb5, 0x04, 0x15, 0xbe, 0x04, 0x32, 0x0b, 0xcc, 0xb5,
	0x68, 0x0f, 0x7c, 0x9a, 0x8e, 0x72, 0x16, 0x8f, 0x68, 0x42, 0x25, 0xe7, 0xcc, 0x01, 0xdb, 0x32,
	0xea, 0xa9, 0x13, 0xc3, 0x2f, 0x0d, 0xd8, 0xbe, 0x30, 0x33, 0xf6, 0x87, 0xc0, 0x07, 0xb0, 0x7d,
	0x67, 0x1c, 0x0f, 0xa7, 0x66, 0xdb, 0xdc, 0xb6, 0x33, 0x8f, 0x87, 0x95, 0xbf, 0x86, 0xe0, 0xd2,
	0xef, 0x12, 0x5c, 0xfe, 0x7b, 0x82, 0xcd, 0x3a, 0x82, 0x3b, 0xd0, 0x99, 0x67, 0x60, 0x19, 0x86,
	0xdf, 0x3d, 0xd8, 0x3e, 0x96, 0x48, 0x35, 0xfe, 0xb3, 0x69, 0x7c, 0x00, 0x1b, 0x33, 0xd3, 0xe8,
	0xe6, 0x10, 0xa6, 0x73, 0x58, 0xf2, 0x9e, 0x2f, 0x29, 0xfe, 0x58, 0xd0, 0x2b, 0x83, 0x66, 0x2d,
	0x6a, 0xcf, 0xd5, 0xf5, 0xa6, 0xa0, 0x57, 0xe4, 0x1e, 0xac, 0x2a, 0x7a, 0x83, 0xb1, 0xe6, 0xa6,
	0xf6, 0xf5, 0x68, 0xa5, 0xfc, 0xfb, 0x8e, 0x87, 0x8f, 0xa1, 0x33, 0x5f, 0x9b, 0x1b, 0x1c, 0x02,
	0xcb, 0xe6, 0x7a, 0xda, 0xbb, 0x6c, 0xbe, 0x0f, 0xbf, 0x36, 0xc0, 0xb7, 0xb6, 0x0b, 0xf7, 0x1e,
	0x91, 0x17, 0xb0, 0xea, 0x5e, 0x05, 0xf2, 0xbf, 0x6b, 0xc8, 0xfc, 0x3b, 0xd4, 0xdd, 0xf9, 0x59,
	0x76, 0x1b, 0xbc, 0x02, 0x98, 0xce, 0x2b, 0x09, 0x9c, 0xeb, 0x97, 0x3b, 0xdf, 0xdd, 0xad, 0x89,
	0xb8, 0x25, 0x4e, 0x60, 0x73, 0xb6, 0x61, 0xa4, 0xeb, 0xac, 0x35, 0x93, 0xdc, 0xbd, 0x5f, 0x1b,
	0x9b, 0x2e, 0x34, 0x0b, 0xa1, 0x5a, 0xa8, 0xa6, 0xeb, 0xd5, 0x42, 0x75, 0xd4, 0x8e, 0x1e, 0xbd,
	0x0f, 0xaf, 0x72, 0x9d, 0x8d, 0x87, 0x83, 0x84, 0x8f, 0x0e, 0xc4, 0xb5, 0x7e, 0x9a, 0x50, 0x95,
	0x95, 0x1f, 0xe9, 0x41, 0xc1, 0xca, 0x9f, 0x14, 0xc9, 0x70, 0xc5, 0xbc, 0xd9, 0xcf, 0x7f, 0x04,
	0x00, 0x00, 0xff, 0xff, 0xf9, 0x22, 0x50, 0x2c, 0xdd, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// WalletUnlockerClient is the client API for WalletUnlocker service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WalletUnlockerClient interface {
	//
	//GenSeed is the first method that should be used to instantiate a new lnd
	//instance. This method allows a caller to generate a new aezeed cipher seed
	//given an optional passphrase. If provided, the passphrase will be necessary
	//to decrypt the cipherseed to expose the internal wallet seed.
	//
	//Once the cipherseed is obtained and verified by the user, the InitWallet
	//method should be used to commit the newly generated seed, and create the
	//wallet.
	GenSeed(ctx context.Context, in *GenSeedRequest, opts ...grpc.CallOption) (*GenSeedResponse, error)
	//
	//InitWallet is used when lnd is starting up for the first time to fully
	//initialize the daemon and its internal wallet. At the very least a wallet
	//password must be provided. This will be used to encrypt sensitive material
	//on disk.
	//
	//In the case of a recovery scenario, the user can also specify their aezeed
	//mnemonic and passphrase. If set, then the daemon will use this prior state
	//to initialize its internal wallet.
	//
	//Alternatively, this can be used along with the GenSeed RPC to obtain a
	//seed, then present it to the user. Once it has been verified by the user,
	//the seed can be fed into this RPC in order to commit the new wallet.
	InitWallet(ctx context.Context, in *InitWalletRequest, opts ...grpc.CallOption) (*InitWalletResponse, error)
	// lncli: `unlock`
	//UnlockWallet is used at startup of lnd to provide a password to unlock
	//the wallet database.
	UnlockWallet(ctx context.Context, in *UnlockWalletRequest, opts ...grpc.CallOption) (*UnlockWalletResponse, error)
	// The create command is used to initialize an lnd wallet from scratch for
	//the very first time.
	CreateWallet(ctx context.Context, in *CreateWalletRequest, opts ...grpc.CallOption) (*CreateWalletResponse, error)
}

type walletUnlockerClient struct {
	cc *grpc.ClientConn
}

func NewWalletUnlockerClient(cc *grpc.ClientConn) WalletUnlockerClient {
	return &walletUnlockerClient{cc}
}

func (c *walletUnlockerClient) GenSeed(ctx context.Context, in *GenSeedRequest, opts ...grpc.CallOption) (*GenSeedResponse, error) {
	out := new(GenSeedResponse)
	err := c.cc.Invoke(ctx, "/lnrpc.WalletUnlocker/GenSeed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletUnlockerClient) InitWallet(ctx context.Context, in *InitWalletRequest, opts ...grpc.CallOption) (*InitWalletResponse, error) {
	out := new(InitWalletResponse)
	err := c.cc.Invoke(ctx, "/lnrpc.WalletUnlocker/InitWallet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletUnlockerClient) UnlockWallet(ctx context.Context, in *UnlockWalletRequest, opts ...grpc.CallOption) (*UnlockWalletResponse, error) {
	out := new(UnlockWalletResponse)
	err := c.cc.Invoke(ctx, "/lnrpc.WalletUnlocker/UnlockWallet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletUnlockerClient) CreateWallet(ctx context.Context, in *CreateWalletRequest, opts ...grpc.CallOption) (*CreateWalletResponse, error) {
	out := new(CreateWalletResponse)
	err := c.cc.Invoke(ctx, "/lnrpc.WalletUnlocker/CreateWallet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WalletUnlockerServer is the server API for WalletUnlocker service.
type WalletUnlockerServer interface {
	//
	//GenSeed is the first method that should be used to instantiate a new lnd
	//instance. This method allows a caller to generate a new aezeed cipher seed
	//given an optional passphrase. If provided, the passphrase will be necessary
	//to decrypt the cipherseed to expose the internal wallet seed.
	//
	//Once the cipherseed is obtained and verified by the user, the InitWallet
	//method should be used to commit the newly generated seed, and create the
	//wallet.
	GenSeed(context.Context, *GenSeedRequest) (*GenSeedResponse, error)
	//
	//InitWallet is used when lnd is starting up for the first time to fully
	//initialize the daemon and its internal wallet. At the very least a wallet
	//password must be provided. This will be used to encrypt sensitive material
	//on disk.
	//
	//In the case of a recovery scenario, the user can also specify their aezeed
	//mnemonic and passphrase. If set, then the daemon will use this prior state
	//to initialize its internal wallet.
	//
	//Alternatively, this can be used along with the GenSeed RPC to obtain a
	//seed, then present it to the user. Once it has been verified by the user,
	//the seed can be fed into this RPC in order to commit the new wallet.
	InitWallet(context.Context, *InitWalletRequest) (*InitWalletResponse, error)
	// lncli: `unlock`
	//UnlockWallet is used at startup of lnd to provide a password to unlock
	//the wallet database.
	UnlockWallet(context.Context, *UnlockWalletRequest) (*UnlockWalletResponse, error)
	// The create command is used to initialize an lnd wallet from scratch for
	//the very first time.
	CreateWallet(context.Context, *CreateWalletRequest) (*CreateWalletResponse, error)
}

// UnimplementedWalletUnlockerServer can be embedded to have forward compatible implementations.
type UnimplementedWalletUnlockerServer struct {
}

func (*UnimplementedWalletUnlockerServer) GenSeed(ctx context.Context, req *GenSeedRequest) (*GenSeedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenSeed not implemented")
}
func (*UnimplementedWalletUnlockerServer) InitWallet(ctx context.Context, req *InitWalletRequest) (*InitWalletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitWallet not implemented")
}
func (*UnimplementedWalletUnlockerServer) UnlockWallet(ctx context.Context, req *UnlockWalletRequest) (*UnlockWalletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnlockWallet not implemented")
}
func (*UnimplementedWalletUnlockerServer) CreateWallet(ctx context.Context, req *CreateWalletRequest) (*CreateWalletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateWallet not implemented")
}

func RegisterWalletUnlockerServer(s *grpc.Server, srv WalletUnlockerServer) {
	s.RegisterService(&_WalletUnlocker_serviceDesc, srv)
}

func _WalletUnlocker_GenSeed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenSeedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletUnlockerServer).GenSeed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.WalletUnlocker/GenSeed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletUnlockerServer).GenSeed(ctx, req.(*GenSeedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletUnlocker_InitWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletUnlockerServer).InitWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.WalletUnlocker/InitWallet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletUnlockerServer).InitWallet(ctx, req.(*InitWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletUnlocker_UnlockWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletUnlockerServer).UnlockWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.WalletUnlocker/UnlockWallet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletUnlockerServer).UnlockWallet(ctx, req.(*UnlockWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletUnlocker_CreateWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletUnlockerServer).CreateWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.WalletUnlocker/CreateWallet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletUnlockerServer).CreateWallet(ctx, req.(*CreateWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _WalletUnlocker_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lnrpc.WalletUnlocker",
	HandlerType: (*WalletUnlockerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GenSeed",
			Handler:    _WalletUnlocker_GenSeed_Handler,
		},
		{
			MethodName: "InitWallet",
			Handler:    _WalletUnlocker_InitWallet_Handler,
		},
		{
			MethodName: "UnlockWallet",
			Handler:    _WalletUnlocker_UnlockWallet_Handler,
		},
		{
			MethodName: "CreateWallet",
			Handler:    _WalletUnlocker_CreateWallet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "walletunlocker.proto",
}
